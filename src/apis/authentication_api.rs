/*
 * EMnify Rest API
 *
 * Rest API resources of the EMnify System.
 *
 * The version of the OpenAPI document: 1.3
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method [`authenticate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticateError {
    Status401(),
    Status404(crate::models::Authenticate404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_mfa`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostMfaError {
    Status409(crate::models::Model40xResponse),
    Status422(crate::models::ChangePassword422Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_mfa_by_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaByIdPatchError {
    Status404(crate::models::Model40xResponse),
    Status409(crate::models::Model40xResponse),
    Status422(crate::models::Model40xResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_mfa_by_user_id_and_key_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaByUserIdAndKeyIdDeleteError {
    Status404(crate::models::Model40xResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_mfa_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaStatusGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_mfa_trusted_device_by_user_id_and_device_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaTrustedDeviceByUserIdAndDeviceIdDeleteError {
    Status404(crate::models::Model40xResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_mfa_trusted_device_by_user_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaTrustedDeviceByUserIdGetError {
    Status404(crate::models::Model40xResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_mfa_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaTypeGetError {
    UnknownValue(serde_json::Value),
}

/// This entrypoint returns a JWT `auth_token` for authenticating further requests to the API.
pub async fn authenticate(
    configuration: &configuration::Configuration,
    authentication: crate::models::Authentication,
) -> Result<crate::models::AuthenticationResponse, Error<AuthenticateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/authenticate", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&authentication);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthenticateError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Generate and store a MFA key for the requesting user. The MFA key will have the status `activation pending` after this call and must be activated through a separate call (`/api/v1/user/mfa/{id}`). You must provide following fields with this request:  * `type` (Object required)   - id (Number) * `password` (String required) - User password   The **MFA key** object returned by the server contains the following properties:  * `id` (Integer) - The unique ID of this MFA key * `status` (Object) ID (Integer) - Id of status of this MFA key   - `description` (String) - description of the status * `type` (Object) ID (Integer) - Id of type of this MFA key   - `description` (String) - description of the type * `secret_key` (String) - Secret key (encoded in Base32) for this MFA key, will be displayed only on creation * `otpauth` (String) - Secret key as a URI encoded for QR codes, will be displayed only on creation * `creation_date` (Timestamp) - Timestamp when this MFA key was created - type: ISO 8601 timestamp format * `activation_date` (Timestamp) - Timestamp when this MFA key was activated - type: ISO 8601 timestamp format
pub async fn post_mfa(
    configuration: &configuration::Configuration,
    post_mfa_request: crate::models::PostMfaRequest,
) -> Result<crate::models::CreateMfaKeyResponse, Error<PostMfaError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/user/mfa", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&post_mfa_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostMfaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Activate the MFA key of the requesting user.  You must provide following JSON fields in this request:  * `status` (Object required)   - `id` (Number) use 1 for \"ACTIVE\" status  * `code` (String required)  - the 6-digit \"time-based one-time password\" (TOTP) generated with this MFA key for the current Time-Step
pub async fn user_mfa_by_id_patch(
    configuration: &configuration::Configuration,
    key_id: f32,
    activate_mfa_key_request: crate::models::ActivateMfaKeyRequest,
) -> Result<(), Error<UserMfaByIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/user/mfa/{key_id}",
        local_var_configuration.base_path,
        key_id = key_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&activate_mfa_key_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UserMfaByIdPatchError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an MFA key for a given user.  An own MFA key can also be deleted with a call to `/api/v1/user/my/mfa/{key_id}`
pub async fn user_mfa_by_user_id_and_key_id_delete(
    configuration: &configuration::Configuration,
    key_id: f32,
    user_id: f32,
) -> Result<(), Error<UserMfaByUserIdAndKeyIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/user/{user_id}/mfa/{key_id}",
        local_var_configuration.base_path,
        key_id = key_id,
        user_id = user_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UserMfaByUserIdAndKeyIdDeleteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of possible MFA Key statuses.
pub async fn user_mfa_status_get(
    configuration: &configuration::Configuration,
) -> Result<Vec<crate::models::MfaKeyStatusLookupresponse>, Error<UserMfaStatusGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/user/mfa/status",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UserMfaStatusGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a trusted device.  Removing one's own trusted device can also be performed at either `/api/v1/user/my/mfa/trusted_device/{id}` or `/api/v1/user/mfa/trusted_device/{id}`
pub async fn user_mfa_trusted_device_by_user_id_and_device_id_delete(
    configuration: &configuration::Configuration,
    user_id: f32,
    device_id: f32,
) -> Result<(), Error<UserMfaTrustedDeviceByUserIdAndDeviceIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/user/{user_id}/mfa/trusted_device/{device_id}",
        local_var_configuration.base_path,
        user_id = user_id,
        device_id = device_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UserMfaTrustedDeviceByUserIdAndDeviceIdDeleteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the list of trusted devices for a given user.  The list of one's own trusted devices can also be retrieved with a call to either `/api/v1/user/my/mfa/trusted_device` or `/api/v1/user/mfa/trusted_device`
pub async fn user_mfa_trusted_device_by_user_id_get(
    configuration: &configuration::Configuration,
    user_id: f32,
) -> Result<
    Vec<crate::models::Listoftrusteddevicesresponse>,
    Error<UserMfaTrustedDeviceByUserIdGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/user/{user_id}/mfa/trusted_device",
        local_var_configuration.base_path,
        user_id = user_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UserMfaTrustedDeviceByUserIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of possible MFA Key types.
pub async fn user_mfa_type_get(
    configuration: &configuration::Configuration,
) -> Result<Vec<crate::models::MfaKeyTypeLookupresponse>, Error<UserMfaTypeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/user/mfa/type", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UserMfaTypeGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
