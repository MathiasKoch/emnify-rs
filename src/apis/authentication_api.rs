/*
 * EMnify Rest API
 *
 * Rest API resources of the EMnify System.
 *
 * The version of the OpenAPI document: 1.2.26
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `authenticate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticateError {
    Status401(),
    Status404(crate::models::InlineResponse404),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_mfa`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostMfaError {
    Status409(crate::models::Response40x),
    Status422(crate::models::ChangePassword422response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `user_mfa_by_id_patch`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaByIdPatchError {
    Status404(crate::models::Response40x),
    Status409(crate::models::Response40x),
    Status422(crate::models::Response40x),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `user_mfa_by_user_id_and_key_id_delete`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaByUserIdAndKeyIdDeleteError {
    Status404(crate::models::Response40x),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `user_mfa_status_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaStatusGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `user_mfa_trusted_device_by_user_id_and_device_id_delete`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaTrustedDeviceByUserIdAndDeviceIdDeleteError {
    Status404(crate::models::Response40x),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `user_mfa_trusted_device_by_user_id_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaTrustedDeviceByUserIdGetError {
    Status404(crate::models::Response40x),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `user_mfa_type_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMfaTypeGetError {
    UnknownValue(serde_json::Value),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticationResponse {
    ApplicationTokenAuthentication(ApplicationTokenAuthenticationResponse),
    UserPasswordAuthentication(UserPasswordAuthenticationResponse),
    UserAuthenticationWithMfaEnabled(UserAuthenticationWithMfaEnabledResponse),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApplicationTokenAuthenticationResponse {
    #[serde(rename = "auth_token")]
    pub auth_token: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPasswordAuthenticationResponse {
    #[serde(rename = "auth_token")]
    pub auth_token: String,
    #[serde(rename = "refresh_token")]
    pub refresh_token: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserAuthenticationWithMfaEnabledResponse {
    #[serde(rename = "mfa_token")]
    pub mfa_token: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPasswordAuthWithDeviceFingerprintResponse {
    #[serde(rename = "username")]
    pub username: String,
    #[serde(rename = "password")]
    pub password: String,
    #[serde(rename = "fingerprint")]
    pub fingerprint: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticationRequest {
    ApplicationTokenAuthentication(ApplicationTokenAuthentication),
    UserPasswordAuthentication(UserPasswordAuthentication),
    MfaCodeVerification(MfaCodeVerification),
    UserPasswordAuthWithDeviceFingerprint(UserPasswordAuthWithDeviceFingerprint),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApplicationTokenAuthentication {
    #[serde(rename = "application_token")]
    pub application_token: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPasswordAuthentication {
    #[serde(rename = "username")]
    pub username: String,
    #[serde(rename = "password")]
    pub password: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MfaCodeVerification {
    #[serde(rename = "mfa_token")]
    pub mfa_token: String,
    #[serde(rename = "code")]
    pub code: String,
    #[serde(rename = "fingerprint")]
    pub fingerprint: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPasswordAuthWithDeviceFingerprint {
    #[serde(rename = "username")]
    pub username: String,
    #[serde(rename = "password")]
    pub password: String,
    #[serde(rename = "fingerprint")]
    pub fingerprint: String
}

/// This entrypoint returns a JWT `auth_token` for authenticating further requests to the API. 
pub async fn authenticate(configuration: &configuration::Configuration, authentication: AuthenticationRequest) -> Result<AuthenticationResponse, Error<AuthenticateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/authenticate", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&authentication);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthenticateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Generate and store a MFA key for the requesting user. The MFA key will have the status `activation pending` after this call and must be activated through a separate call (`/api/v1/user/mfa/{id}`). You must provide following fields with this request:  * `type` (Object required)   - id (Number) * `password` (String required) - User password   The **MFA key** object returned by the server contains the following properties:  * `id` (Integer) - The unique ID of this MFA key * `status` (Object) ID (Integer) - Id of status of this MFA key   - `description` (String) - description of the status * `type` (Object) ID (Integer) - Id of type of this MFA key   - `description` (String) - description of the type * `secret_key` (String) - Secret key (encoded in Base32) for this MFA key, will be displayed only on creation * `otpauth` (String) - Secret key as a URI encoded for QR codes, will be displayed only on creation * `creation_date` (Timestamp) - Timestamp when this MFA key was created - type: ISO 8601 timestamp format * `activation_date` (Timestamp) - Timestamp when this MFA key was activated - type: ISO 8601 timestamp format 
pub async fn post_mfa(configuration: &configuration::Configuration, inline_object: crate::models::InlineObject) -> Result<crate::models::CreateMfaKeyResponse, Error<PostMfaError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/user/mfa", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostMfaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Activate the MFA key of the requesting user.  You must provide following JSON fields in this request:  * `status` (Object required)   - `id` (Number) use 1 for \"ACTIVE\" status  * `code` (String required)  - the 6-digit \"time-based one-time password\" (TOTP) generated with this MFA key for the current Time-Step 
pub async fn user_mfa_by_id_patch(configuration: &configuration::Configuration, key_id: f32, activate_mfa_key_request: crate::models::ActivateMfaKeyRequest) -> Result<(), Error<UserMfaByIdPatchError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/user/mfa/{key_id}", configuration.base_path, key_id=key_id);
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&activate_mfa_key_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<UserMfaByIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an MFA key for a given user.  An own MFA key can also be deleted with a call to `/api/v1/user/my/mfa/{key_id}` 
pub async fn user_mfa_by_user_id_and_key_id_delete(configuration: &configuration::Configuration, key_id: f32, user_id: f32) -> Result<(), Error<UserMfaByUserIdAndKeyIdDeleteError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/user/{user_id}/mfa/{key_id}", configuration.base_path, key_id=key_id, user_id=user_id);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<UserMfaByUserIdAndKeyIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of possible MFA Key statuses.
pub async fn user_mfa_status_get(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::MfaKeyStatusLookupresponse>, Error<UserMfaStatusGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/user/mfa/status", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UserMfaStatusGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a trusted device.  Removing one's own trusted device can also be performed at either `/api/v1/user/my/mfa/trusted_device/{id}` or `/api/v1/user/mfa/trusted_device/{id}` 
pub async fn user_mfa_trusted_device_by_user_id_and_device_id_delete(configuration: &configuration::Configuration, user_id: f32, device_id: f32) -> Result<(), Error<UserMfaTrustedDeviceByUserIdAndDeviceIdDeleteError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/user/{user_id}/mfa/trusted_device/{device_id}", configuration.base_path, user_id=user_id, device_id=device_id);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<UserMfaTrustedDeviceByUserIdAndDeviceIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the list of trusted devices for a given user.  The list of one's own trusted devices can also be retrieved with a call to either `/api/v1/user/my/mfa/trusted_device` or `/api/v1/user/mfa/trusted_device` 
pub async fn user_mfa_trusted_device_by_user_id_get(configuration: &configuration::Configuration, user_id: f32) -> Result<Vec<crate::models::Listoftrusteddevicesresponse>, Error<UserMfaTrustedDeviceByUserIdGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/user/{user_id}/mfa/trusted_device", configuration.base_path, user_id=user_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UserMfaTrustedDeviceByUserIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of possible MFA Key types.
pub async fn user_mfa_type_get(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::MfaKeyTypeLookupresponse>, Error<UserMfaTypeGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/user/mfa/type", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UserMfaTypeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

