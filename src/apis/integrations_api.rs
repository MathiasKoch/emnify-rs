/*
 * EMnify Rest API
 *
 * Rest API resources of the EMnify System.
 *
 * The version of the OpenAPI document: 1.2.26
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `add_data_stream_filter`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddDataStreamFilterError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_callback_secret`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCallbackSecretError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_callback_url`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCallbackUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_data_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDataStreamError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_callback_secret`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCallbackSecretError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_callback_url`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCallbackUrlError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_data_stream_filter`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDataStreamFilterError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_data_streams`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDataStreamsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_api_callback_secret`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApiCallbackSecretError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_api_callback_ur_ls`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApiCallbackUrLsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_callback_secretby_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCallbackSecretbyIdError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_callback_ur_lby_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCallbackUrLbyIdError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_data_stream_filters`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDataStreamFiltersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_data_streams`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDataStreamsError {
    UnknownValue(serde_json::Value),
}


/// One or more filters by `event_type` can be added to a data stream. When such filters are applied, only events of those type are included in the data stream. 
pub async fn add_data_stream_filter(configuration: &configuration::Configuration, data_stream_id: i32, event_type_id: f32) -> Result<(), Error<AddDataStreamFilterError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/data_stream/{data_stream_id}/filter/event_type/{event_type_id}", configuration.base_path, data_stream_id=data_stream_id, event_type_id=event_type_id);
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<AddDataStreamFilterError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a new secret that may be used by API callbacks.  When an `api_secret` is assigned to a Service Profile with an API callback, API requests towards this URL will contain an `Authorization` header with a JSON Web Token. The `api_secret` is used as the __Signing Key__ of the JWT. 
pub async fn create_callback_secret(configuration: &configuration::Configuration, inline_object2: crate::models::InlineObject2) -> Result<(), Error<CreateCallbackSecretError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/api_secret", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object2);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<CreateCallbackSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create Callback URL
pub async fn create_callback_url(configuration: &configuration::Configuration, body: Option<serde_json::Value>) -> Result<(), Error<CreateCallbackUrlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/api_callback", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<CreateCallbackUrlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Data Streams may be created for real-time streaming of event and usage data in either `JSON` or `CSV` formats. The request body must contain the following properties:  * `stream_historic_data`: `0` - disabled, `1` - enabled, data up to 20 days old will be included in the stream * `data_stream_type`: an object that determines the type of data to be sent. The `id` property must be one of the following:     * `id: 1` - Usage Data     * `id: 2` - Event Data     * `id: 3` - Usage Data & Events * `api_type`: an object that indicates the integration type. Must be one of the following:     * `id: 1` - REST API     * `id: 2` - keen.io     * `id: 3` - DataDog     * `id: 4` - AWS Kinesis     * `id: 5` - __Deprecated__     * `id: 6` - REST API in Bulk Mode     * `id: 7` - Salesforce     * `id: 8` - AWS S3  ##### Additional Properties  The following additional parameters should be added depending on the data stream type:  * `api_parameter`: required for __AWS S3__ and for __AWS Kinesis__ in the format `<region>/<stream_or_bucket_name>` * `event_stream`: required for __Salesforce only__, the ID of the target event stream should be passed in here. * `api_username`: required for __Salesforce, keen.io, Datadog__. For __AWS__ integrations, this must be the ARN of the role with write permissions to the destination resource with a Trust Relationship applied. * `api_password`: required for __Salesforce, keen.io, Datadog__.  ##### API Callback URL  Data streams configured to use __Rest API__, __Rest API in Bulk Mode__ and __Salesforce__ may include an `api_callback` object (see  __/api/v1/api_callback__). The following properties may be included:  * `id` Integer (required): A numerical ID of an __existing API callback__ 
pub async fn create_data_stream(configuration: &configuration::Configuration, inline_object1: Option<crate::models::InlineObject1>) -> Result<(), Error<CreateDataStreamError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/data_stream", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inline_object1);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<CreateDataStreamError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_callback_secret(configuration: &configuration::Configuration, api_secret_id: i32) -> Result<(), Error<DeleteCallbackSecretError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/api_secret/{api_secret_id}", configuration.base_path, api_secret_id=api_secret_id);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteCallbackSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_callback_url(configuration: &configuration::Configuration, api_callback_id: i32) -> Result<(), Error<DeleteCallbackUrlError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/api_callback/{api_callback_id}", configuration.base_path, api_callback_id=api_callback_id);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteCallbackUrlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes event filters applied to a data stream by `event_type` id. 
pub async fn delete_data_stream_filter(configuration: &configuration::Configuration, data_stream_id: i32, event_type_id: f32) -> Result<(), Error<DeleteDataStreamFilterError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/data_stream/{data_stream_id}/filter/event_type/{event_type_id}", configuration.base_path, data_stream_id=data_stream_id, event_type_id=event_type_id);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteDataStreamFilterError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// A data stream may be deleted by ID. The ID is the top-level `id` property returned in each object listed in `GET /data_stream`. 
pub async fn delete_data_streams(configuration: &configuration::Configuration, data_stream_id: i32) -> Result<(), Error<DeleteDataStreamsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/data_stream/{data_stream_id}", configuration.base_path, data_stream_id=data_stream_id);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteDataStreamsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists API callback secrets.  __Note:__ The `secret` property itself is not returned in this call. 
pub async fn get_api_callback_secret(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::InlineResponse2005>, Error<GetApiCallbackSecretError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/api_secret", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetApiCallbackSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_api_callback_ur_ls(configuration: &configuration::Configuration, ) -> Result<Vec<serde_json::Value>, Error<GetApiCallbackUrLsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/api_callback", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetApiCallbackUrLsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_callback_secretby_id(configuration: &configuration::Configuration, api_secret_id: i32) -> Result<crate::models::InlineObject2, Error<GetCallbackSecretbyIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/api_secret/{api_secret_id}", configuration.base_path, api_secret_id=api_secret_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCallbackSecretbyIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_callback_ur_lby_id(configuration: &configuration::Configuration, api_callback_id: i32) -> Result<serde_json::Value, Error<GetCallbackUrLbyIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/api_callback/{api_callback_id}", configuration.base_path, api_callback_id=api_callback_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCallbackUrLbyIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of event filters applied to a data stream. When event filters are applied to data streams, only events of that type are included in a stream. 
pub async fn get_data_stream_filters(configuration: &configuration::Configuration, data_stream_id: i32) -> Result<Vec<crate::models::CreateMfaKeyResponseStatus>, Error<GetDataStreamFiltersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/data_stream/{data_stream_id}/filter/event_type", configuration.base_path, data_stream_id=data_stream_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDataStreamFiltersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_data_streams(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::InlineResponse2004>, Error<GetDataStreamsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/data_stream", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDataStreamsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

