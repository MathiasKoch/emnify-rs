/*
 * EMnify Rest API
 *
 * Rest API resources of the EMnify System.
 *
 * The version of the OpenAPI document: 1.3
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method [`assign_ratezone_inclusive_volume`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssignRatezoneInclusiveVolumeError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_active_organisation_inclusive_volume`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActiveOrganisationInclusiveVolumeError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_organisation_daily_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrganisationDailyStatsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_organisation_hourly_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrganisationHourlyStatsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_organisation_monthly_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrganisationMonthlyStatsError {
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`my_organisation_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MyOrganisationGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organisation_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganisationStatusGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`statistics_daily_by_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StatisticsDailyByIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_organisation_tariff`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOrganisationTariffError {
    Status400(),
    Status404(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// Assign a pre-configured ratezone inclusive volume to the specified organisation.  This can be done in self-service as well as for direct child organisations. Only postpaid customers can assign inclusive volumes in self-service, while parent organisations can assign inclusive volumes for both postpaid and prepaid child organisations. The inclusive volume will be charged and calculated against traffic charges accordingly in every bill that is refreshed from that point on. Inclusive volume is counted per device on a monthly basis, the data can be pooled as well or be treated per individual device.  Only inclusive volumes of ratezones belonging to the tariffs assigned to the selected organisation can be chosen.  Enterprise organisations are only allowed to upgrade to a higher inclusive volume if there is already one active in the current month.  The `start_date` and `end_date` of the inclusive volume denote the billing period which this volume applies to, where the start must be always the first day of a month, and the end the last day. Times of the fields will be stripped. Inclusive volumes can only be assigned for the current or a future month.  The request body for this entrypoint is optional. Default values are: * `start_date`: First day of the current month * `end_date`: `null` (Inclusive volume will run indefinitely until the end date is set.) * `pooled`: `true`
pub async fn assign_ratezone_inclusive_volume(
    configuration: &configuration::Configuration,
    org_id_or_my: &str,
    inclusive_volume_id: f32,
    assign_ratezone_inclusive_volume_request: Option<
        crate::models::AssignRatezoneInclusiveVolumeRequest,
    >,
) -> Result<
    crate::models::AssignRatezoneInclusiveVolume201Response,
    Error<AssignRatezoneInclusiveVolumeError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/organisation/{org_id_or_my}/inclusive_volume/{inclusive_volume_id}",
        local_var_configuration.base_path,
        org_id_or_my = crate::apis::urlencode(org_id_or_my),
        inclusive_volume_id = inclusive_volume_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&assign_ratezone_inclusive_volume_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AssignRatezoneInclusiveVolumeError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns of a list of inclusive volumes that are currently active in the current billing period for the selected organisation. This will not inclusive volumes that are already expired or have the start date set for a future billing period.  Only inclusive volumes for the own organisation or direct child organisations are accessible.
pub async fn get_active_organisation_inclusive_volume(
    configuration: &configuration::Configuration,
    org_id_or_my: &str,
) -> Result<
    Vec<crate::models::GetActiveOrganisationInclusiveVolumeResponseInner>,
    Error<GetActiveOrganisationInclusiveVolumeError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/organisation/{org_id_or_my}/inclusive_volume/active",
        local_var_configuration.base_path,
        org_id_or_my = crate::apis::urlencode(org_id_or_my)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetActiveOrganisationInclusiveVolumeError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves traffic and cost statistics for the selected organisation and all their child organisations, accumulated per day. By default, statistics for the current month will be returned.  To filter the statistics over a time range, a `start_date` and an `end_date` can be provided as query parameters. The filters have to be provided in `<property>=<value>` format.  When defining only the `start_date`, the statistics from that date until the end of the selected month will be returned.  Example request: `/api/v1/organisation/123/stats/daily?end_date=2019-03-03&start_date=2019-03-01`
pub async fn get_organisation_daily_stats(
    configuration: &configuration::Configuration,
    org_id_or_my: &str,
    start_date: Option<String>,
    end_date: Option<String>,
) -> Result<
    Vec<crate::models::GetDailyOrganisationStatsResponseInner>,
    Error<GetOrganisationDailyStatsError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/organisation/{org_id_or_my}/stats/daily",
        local_var_configuration.base_path,
        org_id_or_my = crate::apis::urlencode(org_id_or_my)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = start_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetOrganisationDailyStatsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve traffic statistics for the selected organisation and all their child organisations accumulated per hour. Per default, the statistics of the last three hours will be returned.  To filter the statistics over a time range, a `start_date` and an `end_date` can be provided as query parameters. The filters have to be provided in `<property>=<value>` format.  Example request: `/api/v1/organisation/123/stats/hourly?end_date=2019-03-03&start_date=2019-03-01`
pub async fn get_organisation_hourly_stats(
    configuration: &configuration::Configuration,
    org_id_or_my: &str,
    start_date: Option<String>,
    end_date: Option<String>,
) -> Result<crate::models::GetHourlyOrganisationStatsResponse, Error<GetOrganisationHourlyStatsError>>
{
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/organisation/{org_id_or_my}/stats/hourly",
        local_var_configuration.base_path,
        org_id_or_my = crate::apis::urlencode(org_id_or_my)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = start_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetOrganisationHourlyStatsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves traffic and cost statistics for the selected organisation.  Traffic statistics accumulate for the `current_month` and `last_month` of the selected organisation and all its child organisations. All other returned values (i.e., SIM statistics, user counts, etc.) are only for the selected organisation.
pub async fn get_organisation_monthly_stats(
    configuration: &configuration::Configuration,
    org_id_or_my: &str,
) -> Result<
    crate::models::GetMonthlyOrganisationStatsResponse,
    Error<GetOrganisationMonthlyStatsError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/organisation/{org_id_or_my}/stats",
        local_var_configuration.base_path,
        org_id_or_my = crate::apis::urlencode(org_id_or_my)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetOrganisationMonthlyStatsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// You can retrieve details about your own organisation
pub async fn my_organisation_get(
    configuration: &configuration::Configuration,
) -> Result<crate::models::MyOrganisationGet200Response, Error<MyOrganisationGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/organisation/my",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MyOrganisationGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Provides a list of available organisation status (lookup).
pub async fn organisation_status_get(
    configuration: &configuration::Configuration,
) -> Result<
    Vec<crate::models::RetrieveOrganisationStatusesresponse>,
    Error<OrganisationStatusGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/organisation/status",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OrganisationStatusGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve usage and costs statistics for the currently logged in organisation and all their child organisations accumulated per days from beginning of the month until today. Data traffic costs will not be returned for enterprise organisations with inclusive volume.
pub async fn statistics_daily_by_id_get(
    configuration: &configuration::Configuration,
) -> Result<Vec<serde_json::Value>, Error<StatisticsDailyByIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/stats/daily", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StatisticsDailyByIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Allows an organisation to change their assigned tariff.  The following restrictions apply: * The organisation must not have more than one tariff assigned. * The tariff can be changed only for the own organisation and direct child organisations. The organisation status must be \"ACTIVE\". * If performing the change in self-service, the organisation needs to be in evaluation. Parent organisations are allowed to change the tariffs of production organisations. * The selected tariff must be active, visible to the requested organisation and must have the same currency. Parent organisations are allowed to assign private tariffs to their child organisations.  In addition to updating the assigned tariff, the system will also: * Update all of the organisations tariff profiles to use the new tariff. * Activate all ratezones in the tariff in order to ensure that the endpoints do not lose connection. * Expire all currently active inclusive volumes and custom rates and delete future ones.
pub async fn update_organisation_tariff(
    configuration: &configuration::Configuration,
    org_id: f32,
    update_tariff_request: crate::models::UpdateTariffRequest,
) -> Result<(), Error<UpdateOrganisationTariffError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/organisation/{org_id}/tariff",
        local_var_configuration.base_path,
        org_id = org_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_tariff_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UpdateOrganisationTariffError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
